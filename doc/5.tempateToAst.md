# 解析 template 字符串
## 解析方式
### 推进式处理
将 template 进行推进，遇到需要处理的标识就对应的方案处理
## 需求与结果
template -> ast
## 详细流程
- template 传入 baseParse
  - createParserContext 根据传入 template 创建 context
  - createRoot创建根节点传入 children
    - paseChildren 接收 context 返回 children
      - node 
        - 如果 context.source 以 `{{` 开头进入 paseInterpolation 处理插入值
          - 通过 delimiter 获取到 开始与结束位置
          - 移动 delimiter[0] 位置，到要截取位置
          - 通过 delimiter[1] 获取要截取的结束位置
          - paseTextData 截取 content
          - 为 content 清楚两侧空格
          - advanceBy delimiter[1] 位置
          - 返回 {type,content}
        - 如果 context.source 以`<` 开头 ，并且第二个字符是 `[a-z]` 则按照 tag 处理 paseElement
          - parseTag 传入 开始标记，来处理字符串并返回 tag 
            - 根据 `/^<\/?([a-z]*)/i` 正则获取到 整个字符串 的长度
            - 将 template 推动 整个字符串 的长度
            - 判断是否是开始标记
              - 是 ：返回 正则的 tag
              - 否 ：返回 undefined
          - parseTag 传入 结束，来处理字符串返回 空
          - 返回 {type,tag}
        - 上面两种没有通过则解析为 Text
          - 使用 parseText 解析
            - paseTextData
              - 截取 0 ～ 传入endIndex
              - 返回 content
            - 返回 {type,content}
    - 将 node 存放到 nodes 中 返回