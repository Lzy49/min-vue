# 解析 template 字符串
## 解析方式
### 推进式处理
将 template 进行推进，遇到需要处理的标识就对应的方案处理
## 需求与结果
template -> ast
## 详细流程
- template 传入 baseParse
  - createParserContext 根据传入 template 创建 context
  - 创建 ancestor 用来存放 进出 tag
  - createRoot创建根节点传入 children
    - paseChildren 接收 context , ancestor 返回 children
      - 循环产生 node 
        - isEnd 判断是否结束
          - context.source.length <= 0 证明彻底循环完
          - context.source.startsWith(`</${}>`) 证明遇到闭合标签结束本层循环
            - 判断 结束 tag 是否是 ancestor 最后一个，不是则说明 tag 未闭合
        - node 
          - 如果 context.source 以 `{{` 开头进入 paseInterpolation 处理插入值
            - 通过 delimiter 获取到 开始与结束位置
            - 移动 delimiter[0] 位置，到要截取位置
            - 通过 delimiter[1] 获取要截取的结束位置
            - paseTextData 截取 content
            - 为 content 清楚两侧空格
            - advanceBy delimiter[1] 位置
            - 返回 {type,content}
          - 如果 context.source 以`<` 开头 ，并且第二个字符是 `[a-z]` 则按照 tag 处理 paseElement(context,ancestor)
            - parseTag 接收字符串，是否是开头 处理字符串并在开头时返回 tag
              - 根据 `/^<\/?([a-z]*)/i` 正则获取到 整个字符串 的长度
                - 将 template 推动 整个字符串 的长度
                - 判断是否是开始标记
                  - 是 ：返回 正则的 tag
                  - 否 ：返回 undefined
            - 处理开头 parseTag 传入 context,开始标记。返回 tag
              - ancestor 推入 tag
            - 处理 children 使用 paseChildren 传入 context，ancestor
              - ancestor 推出 tag
            - parseTag 传入 结束，来处理字符串返回 空
            - 返回 {type,tag}
          - 上面两种没有通过则解析为 Text
            - 使用 parseText 解析
              - 解析 endIndex
                - `{{` 为结束
                - `<` 为结束
              - paseTextData
                - 截取 0 ～ 传入endIndex
                - 返回 content
              - 返回 {type,content}
      - 将 node 存放到 nodes 中 返回