# 24-实现 shapeFlags
### 这节课讲了什么
- 讲了使用 shapeFlags 实现类型判定
- 使用二进制数来优化 判定过程。
### 核心
#### 二进制
- 利用二进制数 ｜ & 来做判定，来确定多权限，是否合规
  - ｜ 代表 0 ｜ 1  === 1 ， 1 ｜ 1 === 1 ， 0 ｜ 0 === 0
  - & 代表  1 & 1 === 1 ，0 & 1 === 0
- 设置权限使用 << 来设置数比如 1 << 1 === 0010 , 1 << 2 === 0100
- 多权限可以使用  | 比如 1 << 1 | 1 << 2 === 0110
- 权限判定可以使用 & 比如 0010 & 0110 > 0  , 0000 & 0010 === 0
#### 实现
在 createNode 时增加 ShapeFlags 属性
- 通过判断 type 类型来设置 元素 & 文字
- 通过判断 children 设置 有文字子元素 & 数组子元素
### 思想
ShapeFlags 思想 
- 当遇到需要校验的问题时，可以使用 ShapeFlags 来完成。它本质就是利 用一个固定的 Flag 表示一些意义。方便判断。
- 在实现Flag时可以使用二进制来完成。 这样更加高效。
### 运行流程
#### 设置元素 
h->createNode->判断type 设置 shapeFlag -> 判断 children 设置 shapeFlag
#### 判断
render->path->判断shapeFlag确定元素类型->processElement->mountElement-> 判断 shapeFlag -> 处理

# 25-实现注册事件功能
### 这节课讲讲什么  
如何实现 事件绑定
### 核心
- 判断 传入的参数中的key是否符合/^on[A-Z]/ 
- 使用 addEventListener 绑定
### 思想
### 运行流程
h->createNode->path->processElement->mountElement->处理props

# 26-实现组件 props 逻辑
### 这节课讲了什么
如何实现 props
### 核心
#### props 初始化
通过 vnode 传的 props 绑定在 instance 上
#### props 传入 setup
在调用setup 时 传入 props ，并且 props 应该是 shallowReadonly 值。
#### props 传入 this
在 componentPublic 中 实现 代理
### 技巧
- Object.prototype.hasOwnProperty.call(state, key) // 取自己
- Reflect.has(state, key)  和 key in state 相同 // 取自己 + 原型链
### 运行流程
h->createNode->path->processComponent->mountComponent->createComponentInstance 创建 instance-> setupComponent 处理各种option -> initProps 处理 vnode 传来的props->setupStatefulComponent 处理 instance ->  更新->调用 setup 传入 shallowReadonly(props) -> 处理 setup 返回值 -> setupRenderEffect 继续调用path更新组件
# 27-实现组件 emit 功能
### 这节课讲了什么
如何实现 emit 的功能
### 核心
- emit 其实是一个函数这个函数会传给 setup 的第二个参数中的对象中。
- emit 接收多个值，其中第一个值是 event 
- 通过 event 找到 props 中 on + Event 的函数并为其传参，并执行。
### 技巧
课程中再次展示TPP的思想。先实现了一个 onAdd 后面又进行了通用化 去重构 capitalize , toHandlerKey来解析 event 最后又增加了camelize对 'on-add' 字符串的支持 
### 运行流程
h->createNode -> path -> processComponent -> mountComponent -> createComponentInstance 创建 instanc -> 初始化 emit 函数 -> setupComponent 处理 option -> 更新 -> 调用 setup 传入 instanc.emit -> ...
# 28-实现组件 slots 功能
### 这节课讲了什么
slots 功能 实现
- 不具名 slots 实现
- 具名 slots 实现
- 作用域 slots 实现
### 核心
- 增加 initSlot 将 slot 处理统一。
  - 处理 函数
- 增加 ShapeFlag 来判定是否是有 slot 的组件
- 增加 this.$slots 代理 instance.vnode.children
- 增加 renderSlot 来处理 initSlot 来创建 vnode
### 运行流程
h->createNode->path->processComponent->mountComponent -> createComponentInstance -> setupComponent -> initSlots -> setupStatefulComponent 挂载 this.$slots -> ...
# 29-实现 Fragment 和 Text 类型节点
### 这节课讲了什么
- Fragment 实现
- Text 类型节点实现
### 核心
- Fragment 和 Text 都是特殊节点处理。他们都是在 path 中进行单独处理
- Fragment 核心逻辑是 调用 mountChildren 来生成新的节点，直接注入到 包裹 Fragment 的元素节点中
- Text 类型 核心逻辑是 如同创建 Element 一样 创建 textNode 然后进行注入即可。

### 运行流程
#### Fragment
h->createNode->path 进行判断 如果是 Fragment 则调用 mountChildren 传入 当前 容器。 -> 调用 path -> 继续调用 processComponent & processElement & processText
#### Text 类型
createTextVnode -> path 判断 type === text -> 调用 processText -> 调用 document.createTextNode() -> 挂载到 容器中

# 30-实现 getCurrentInstance 
### 核心
getCurrentInstance composition API  的一些要求
- 只能在 setup 中使用
- 获取 当前组件的 instace 
所以在 调用 setup 时赋值给 currentInstance 在 setup 调用结束后 删除 currentInstance 的
### 技巧
- 为单独的流程增加方法来方便后期维护
### 运行流程
processComponent -> mountComponent -> createComponentInstance -> setupComponent -> setupStatefulComponent 中 -> setCurrentInstance -> setup ->removeCurrentInstance -> setupRenderEffect
# 31-实现 provide-inject 功能
### 核心
- provide 
  - 本质是往自己身上挂一个 对象，来存一状态。
  - provide 不但要提供自己的 provide 也要提供上级的 provide 这样一层层的上去。 使用 JavaScript 的原型链机制来保证。
- inject
  - inject 是去取上一级的 provide 中的状态。
    - 因为是定义本层 provide 时是创建了新对象，所以 provide 不会混
    - default 算是锦上添花
- parent 的传递 只有 component 组件需要传递 parent , 其他类型传递 null 即可。
### 技巧
- 不要想太多，只要实现，一个小功能即可。然后如果有新的扩展再在基础上增加、重构。不要过分设计。
- 利用原型链形式巧妙的处理了顶组件往下传递的痛点，还有对象内存共用。

### 运行流程
- 第一个组件 没有 parent 传入 null
  - path -> processComponent -> mountComponent -> createComponentInstance 接受 parent ， 设置 provide = {}
- 内部组件 有 parent 在 setupRenderEffect 向下传递 instance

# 32-实现自定义渲染器 custom renderer
### 核心
customRenderer 讲的是将渲染功能独立成稳定的接口而不依赖于任何平台。在核心代码的内部只调用接口来处理问题，其从根本解决了跨平台的问题。且将代码抽离后，可读性更高，调试更加方便。
- 新增 runtime-dom 实现基于DOM的实现流程：完成了以下几件事
  - 接收 createRenderer 
  - 创建 渲染器
  - 执行 createRenderer 返回 createApp
  - 抛出 createApp 和 runtime-core 的外部引入
- 改造 createApp : 由于 render 不能直接引入需要在创建时引入，所以createApp需要在 createRenderer 执行后接收 render 再抛出render
- 改造 renderer : 
  - 因为渲染功能使用了接口而接口需要传过来。所以要接收渲染接口，使用 createRenderer 来包裹，并接收一个渲染option执行内部的渲染。
  - render 只在 createApp 使用了所以直接将 createApp 纳入 createRenderer 返回。
# 33-更新element流程搭建
### 核心
- vue 项目的更新是通过 vm 修改虚拟dom 然后更新 element 的。所以 更新是由 修改数据后 执行的。这个过程的实现是由 effect 执行 render ，在 render 中使用的状态都被收集到了对应响应属性的 deps中。从而实现修改数据更新。
- render 是用来生成 虚拟dom并渲染的。但是目前我们的机制是通过分析 Vnode -> 转换虚拟dom树 -> 渲染的过程,所以每次 执行 effect 的时候会产生新的dom并挂载在页面中。这是不对的，所以我们要增加更新的环节。 effect 执行的第一次 去挂载，而后面去执行则去修改。
- 有修改，就要有比较。所以就要有新旧Vnode。所以要在 path 的过程中增加 新旧DOM树，去处理。

### 注意点
- 只有组件才有修改更新的需求所以只需要在组件的模块做 effect 就可以