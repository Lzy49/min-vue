# 24-实现 shapeFlags
### 这节课讲了什么
- 讲了使用 shapeFlags 实现类型判定
- 使用二进制数来优化 判定过程。
### 核心
#### 二进制
- 利用二进制数 ｜ & 来做判定，来确定多权限，是否合规
  - ｜ 代表 0 ｜ 1  === 1 ， 1 ｜ 1 === 1 ， 0 ｜ 0 === 0
  - & 代表  1 & 1 === 1 ，0 & 1 === 0
- 设置权限使用 << 来设置数比如 1 << 1 === 0010 , 1 << 2 === 0100
- 多权限可以使用  | 比如 1 << 1 | 1 << 2 === 0110
- 权限判定可以使用 & 比如 0010 & 0110 > 0  , 0000 & 0010 === 0
#### 实现
在 createNode 时增加 ShapeFlags 属性
- 通过判断 type 类型来设置 节点 & 文字
- 通过判断 children 设置 有文字子节点 & 数组子节点
### 思想
ShapeFlags 思想 
- 当遇到需要校验的问题时，可以使用 ShapeFlags 来完成。它本质就是利 用一个固定的 Flag 表示一些意义。方便判断。
- 在实现Flag时可以使用二进制来完成。 这样更加高效。
### 运行流程
#### 设置节点 
h->createNode->判断type 设置 shapeFlag -> 判断 children 设置 shapeFlag
#### 判断
render->patch->判断shapeFlag确定节点类型->processElement->mountElement-> 判断 shapeFlag -> 处理

# 25-实现注册事件功能
### 这节课讲讲什么  
如何实现 事件绑定
### 核心
- 判断 传入的参数中的key是否符合/^on[A-Z]/ 
- 使用 addEventListener 绑定
### 思想
### 运行流程
h->createNode->patch->processElement->mountElement->处理props

# 26-实现组件 props 逻辑
### 这节课讲了什么
如何实现 props
### 核心
#### props 初始化
通过 vnode 传的 props 绑定在 instance 上
#### props 传入 setup
在调用setup 时 传入 props ，并且 props 应该是 shallowReadonly 值。
#### props 传入 this
在 componentPublic 中 实现 代理
### 技巧
- Object.prototype.hasOwnProperty.call(state, key) // 取自己
- Reflect.has(state, key)  和 key in state 相同 // 取自己 + 原型链
### 运行流程
h->createNode->patch->processComponent->mountComponent->createComponentInstance 创建 instance-> setupComponent 处理各种option -> initProps 处理 vnode 传来的props->setupStatefulComponent 处理 instance ->  更新->调用 setup 传入 shallowReadonly(props) -> 处理 setup 返回值 -> setupRenderEffect 继续调用patch更新组件
# 27-实现组件 emit 功能
### 这节课讲了什么
如何实现 emit 的功能
### 核心
- emit 其实是一个函数这个函数会传给 setup 的第二个参数中的对象中。
- emit 接收多个值，其中第一个值是 event 
- 通过 event 找到 props 中 on + Event 的函数并为其传参，并执行。
### 技巧
课程中再次展示TPP的思想。先实现了一个 onAdd 后面又进行了通用化 去重构 capitalize , toHandlerKey来解析 event 最后又增加了camelize对 'on-add' 字符串的支持 
### 运行流程
h->createNode -> patch -> processComponent -> mountComponent -> createComponentInstance 创建 instanc -> 初始化 emit 函数 -> setupComponent 处理 option -> 更新 -> 调用 setup 传入 instanc.emit -> ...
# 28-实现组件 slots 功能
### 这节课讲了什么
slots 功能 实现
- 不具名 slots 实现
- 具名 slots 实现
- 作用域 slots 实现
### 核心
- 增加 initSlot 将 slot 处理统一。
  - 处理 函数
- 增加 ShapeFlag 来判定是否是有 slot 的组件
- 增加 this.$slots 代理 instance.vnode.children
- 增加 renderSlot 来处理 initSlot 来创建 vnode
### 运行流程
h->createNode->patch->processComponent->mountComponent -> createComponentInstance -> setupComponent -> initSlots -> setupStatefulComponent 挂载 this.$slots -> ...
# 29-实现 Fragment 和 Text 类型节点
### 这节课讲了什么
- Fragment 实现
- Text 类型节点实现
### 核心
- Fragment 和 Text 都是特殊节点处理。他们都是在 patch 中进行单独处理
- Fragment 核心逻辑是 调用 mountChildren 来生成新的节点，直接注入到 包裹 Fragment 的节点中
- Text 类型 核心逻辑是 如同创建 Element 一样 创建 textNode 然后进行注入即可。

### 运行流程
#### Fragment
h->createNode->patch 进行判断 如果是 Fragment 则调用 mountChildren 传入 当前 容器。 -> 调用 patch -> 继续调用 processComponent & processElement & processText
#### Text 类型
createTextVnode -> patch 判断 type === text -> 调用 processText -> 调用 document.createTextNode() -> 挂载到 容器中

# 30-实现 getCurrentInstance 
### 核心
getCurrentInstance composition API  的一些要求
- 只能在 setup 中使用
- 获取 当前组件的 instace 
所以在 调用 setup 时赋值给 currentInstance 在 setup 调用结束后 删除 currentInstance 的
### 技巧
- 为单独的流程增加方法来方便后期维护
### 运行流程
processComponent -> mountComponent -> createComponentInstance -> setupComponent -> setupStatefulComponent 中 -> setCurrentInstance -> setup ->removeCurrentInstance -> setupRenderEffect
# 31-实现 provide-inject 功能
### 核心
- provide 
  - 本质是往自己身上挂一个 对象，来存一状态。
  - provide 不但要提供自己的 provide 也要提供上级的 provide 这样一层层的上去。 使用 JavaScript 的原型链机制来保证。
- inject
  - inject 是去取上一级的 provide 中的状态。
    - 因为是定义本层 provide 时是创建了新对象，所以 provide 不会混
    - default 算是锦上添花
- parent 的传递 只有 component 组件需要传递 parent , 其他类型传递 null 即可。
### 技巧
- 不要想太多，只要实现，一个小功能即可。然后如果有新的扩展再在基础上增加、重构。不要过分设计。
- 利用原型链形式巧妙的处理了顶组件往下传递的痛点，还有对象内存共用。

### 运行流程
- 第一个组件 没有 parent 传入 null
  - patch -> processComponent -> mountComponent -> createComponentInstance 接受 parent ， 设置 provide = {}
- 内部组件 有 parent 在 setupRenderEffect 向下传递 instance

# 32-实现自定义渲染器 custom renderer
### 核心
customRenderer 讲的是将渲染功能独立成稳定的接口而不依赖于任何平台。在核心代码的内部只调用接口来处理问题，其从根本解决了跨平台的问题。且将代码抽离后，可读性更高，调试更加方便。
- 新增 runtime-dom 实现基于DOM的实现流程：完成了以下几件事
  - 接收 createRenderer 
  - 创建 渲染器
  - 执行 createRenderer 返回 createApp
  - 抛出 createApp 和 runtime-core 的外部引入
- 改造 createApp : 由于 render 不能直接引入需要在创建时引入，所以createApp需要在 createRenderer 执行后接收 render 再抛出render
- 改造 renderer : 
  - 因为渲染功能使用了接口而接口需要传过来。所以要接收渲染接口，使用 createRenderer 来包裹，并接收一个渲染option执行内部的渲染。
  - render 只在 createApp 使用了所以直接将 createApp 纳入 createRenderer 返回。
# 33-更新element流程搭建
### 核心
- vue 项目的更新是通过 vm 修改虚拟dom 然后更新 element 的。所以 更新是由 修改数据后 执行的。这个过程的实现是由 effect 执行 render ，在 render 中使用的状态都被收集到了对应响应属性的 deps中。从而实现修改数据更新。
- render 是用来生成 虚拟dom并渲染的。但是目前我们的机制是通过分析 Vnode -> 转换虚拟dom树 -> 渲染的过程,所以每次 执行 effect 的时候会产生新的dom并挂载在页面中。这是不对的，所以我们要增加更新的环节。 effect 执行的第一次 去挂载，而后面去执行则去修改。
- 有修改，就要有比较。所以就要有新旧Vnode。所以要在 patch 的过程中增加 新旧DOM树，去处理。

### 注意点
- 只有组件才有修改更新的需求所以只需要在组件的模块做 effect 就可以
# 34-更新element 的 props
### 核心
- 本课主要内容是修改 element 的 props 执行的时间是在 更新 element 类型 节点的时候执行。
- 修改 element props 有 3种情况
  1. 老element中有，新element中无 -> 删除
  2. 新element中有，老element中无 -> 增加
  3. 新element中有，但是是undefined || null -> 删除
- 以上的操作应该在 对比 element 的 props 时执行 所以在 patchProps 时执行，patchProps 在 updateElement 时执行

# 35-更新 element 的 children
### 核心
- 本课主要内容是 修改 子节点的内容。其中分为4部分，本课讲3部分
  - 老节点为文本子节点，新节点为文本子节点 -> 判断是否一致 -> 修改
  - 老节点为文本子节点，新节点为数组子节点 -> 删除老节点中的文本节点 -> 添加新节点中的数组节点
  - 老节点为数组节点，新节点为文本节点 -> 删除老节点 -> 增加新节点文本节点
  - 老节点为数组节点，新节点为数组节点 -> 下集将
- 根据上述需求增加两个新的DOM-API
  - remove 删除节点API
  - setElementText 设置节点文本

# 36-更新 element 的 children - 双端对比diff 算法 （1）
### 核心
- 本节课的内容是 双端比较
  - 为什么要双端比较：
    - 缩小范围
    - 实际业务需求：我们在修改dom的大多数操作是在某某节点之后，之前增加或删除，很少进行全部删除。所以进行双端比较可以有效缩小乱序范围。
  - 比较方法
    - 从左到右比较
      - 因为下标都是 0 所以用 i 来比较，直到 不相同 break
      - 相同时 path 比较子节点
    - 从右到左比较
      - 因为下标不同都是数组长度 - 1 所以用 他们各自的长度定义的变量（nextR,prevR)来比较。直到不同 break
      - 相同时 path 比较子节点
  - 对比较后的结果来执行
    - nextR !== prevR -> 说明确实有增，减
      - i > nextR && i <=prevR -> 旧节点比新节点多 -> 删除
      - i <= nextR && i > prevR -> 旧节点比新节点少 -> 增加
        - 增加后乱序问题：要根据 prevR 来确定 el ，并在这个 el 前增加。 
# 37-更新 element 的 children - 双端对比diff 算法 （2）
### 核心
- 本节课内容是双端比较后的结余进行增减后再进行处理解决：1. 删除多余节点，2. 对合适节点进行属性修改以及递归判断
  - 比较方法是 循环比较 ：
    - 循环 旧节点组
      - 循环在新节点组中寻找
      - 找到path子节点跳出，继续循环下一个旧节点
      - 没找到 删除
    - 优化点
      - 再循环的过程中每次循环新节点去查找不合适，所以使用key查询法：
        - 再写代码时，我们给标签增加 key props 
        - 进入循环旧节点前 先循环新节点 ，用新节点生成一个 key->index 组。
        - 如果 可以 通过 key 查询到 index 则不需要循环再新节点组中查找。
      - 利用新节点数来确定删除节点
        - 循环旧节点时，会出现旧节点 > 新节点的情况。还会出现 第一个节点不同（前面双端判断）第二个到某一个是相同的，后面所有的都不同的情况。这种情况就可以利用 新节点长度来优化：
          - 再循环旧节点前，获取长度。
          - 在path子节点的时，记录个数
          - 下次循环比较 记录个数与长度是否相同。
            - 相同，后面节点删除
            - 不同，继续
# 38-更新 element 的 children - 双端对比diff 算法 （3）
### 核心
- 移动相同个节点 
  - 移动方式：比较新旧两个数组，位置不同的去移动。
  - 优化1:问题：如果有连着的一排不需要移动的，那么去一个一个移动是耗性能的。所以要避免移动连着的长的序列
    - 解决：最长子序列 找出要不动的点。
  - 移动方式：
    - 循环判断所有新点
      - 求最长子序列 
        - 收集映射
          - 创建映射
            - 根据新节点长度 创建一个 全部为 0 的 数组 （ key => nextIndex, value=>prevIndex)
          - 收集映射
            - 在删除旧节点的循环中不删除的就是旧与新都存在的
              - 在不删除时，得到旧节点 index, 存入映射中 新节点 - i => 旧 index + 1
                - 此处 旧 index + 1 只用来最长子序列排序。所以无所谓
          - 收集后得到一个 映射，关系 为 新最小序列index  => 旧最小序列index+1
        - 通过映射得到一个根据旧节点index的最长子序列。这个是不动的
      - 循环
        - 创建 最长子序列 下标记录
        - 循环 nextR ~ 0。
        - 判断 映射中 下标 为 index 是否 等于 0
          - 等 （说明是新节点）
            - 新增这个新节点 path(null,nextChildren[index + nextIndex])
          - 不等 （说明在上面收集到了，结果是 +1 的）
            - 判断这个点是不是最长子序列的中的一员
              - 是 
                - 最长子序列下标+1 ，不要碰他
              - 否
                - 这个点是个要移动的点 
                - 插入点就是当前 nextChildren[index  + nextIndex] 
                - 插入位置，因为是 从 nextR - 0 的 所以 是从后往前的。最后一个点是 当前点 index + 1(为 undefined 也不怕最后插入)
  - 优化2:问题是否真的有点需要移动。
    - 解决：在删除记录的循环中是按照旧节点进行循环的，如果知道的心节点的 index 越来越大则不需要排序，如果出现大的在小的前面则需要排序
  - 优化3:当循环一会儿后，发现最长子序列已经全部过去了。剩下的点全部需要移动了。
    - 这个时候不必再去最长子序列中找了。直接移动就完事了。
# 40-实现组件更新功能
### 核心
- 更新组件流程
  - 更新组件时机
    - 组件自身更新
      - 修改 setup 返回的 reactive 值
      - 修改后触发 effect 
    - 组件因父组件props值更新而更新
      - 父组件path后判定子组件是一个component组件，执行 updateComponent 来更新
        - 统一 instance 实例 instance = 新虚拟节点的 instance = 旧虚拟节点的 instance （因为这个是创建时就确定的）
        - 判断父组件给的props是否有改变。
          - 无改变，不做更新，该节点 以及该节点子节点都没有被影响
            -  将 旧vnode 的el赋值给 新vnode 的el（因为一样）
            -  将 旧组件实例 赋值给 新组件实例 （因为一样）
            -  将 新的vnode 赋给当前的组件实例（组件实例在最上面已经统一）
          - 有改变，更新
            -  instance.next = nextVnode 因为 runner 更新的是因为 props 
            -  执行 effect update 
               - 判断下有没有  nextVnode  
                 - 有值
                   - 更新 新vnode.el = 旧vnode.el
                   - 更新 instance 的一切与 vnode 相关内容
                     - instance.props = vnode.props
                     - instance.vnode = nextVnode
                   - 将 instance.next 设置为 null (用完就删)
                 - 无值不处理
               - 通过上面的处理得到修改了props的instance。
               - 通过 instance.subTree 获取到旧 vnode 树
               - 通过 instance.render 生成新的 vnode 树
               - 将 instance.subTree 设置为新的
               - path 子节点对比
